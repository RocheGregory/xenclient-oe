diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 851b585..32210b2 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -523,8 +523,10 @@ int i915_gem_obj_prepare_shmem_read(struct drm_i915_gem_object *obj,
 	}
 
 	ret = i915_gem_object_get_pages(obj);
-	if (ret)
+	if (ret) {
+		DRM_DEBUG_DRIVER("i915_gem_object_get_pages failed\n");
 		return ret;
+        }
 
 	i915_gem_object_pin_pages(obj);
 
@@ -2129,6 +2131,7 @@ i915_gem_object_get_pages_gtt(struct drm_i915_gem_object *obj)
 	return 0;
 
 err_pages:
+	DRM_DEBUG_DRIVER("shmem_read_mapping_page_gfp failed\n");
 	sg_mark_end(sg);
 	for_each_sg_page(st->sgl, &sg_iter, st->nents, 0)
 		page_cache_release(sg_page_iter_page(&sg_iter));
@@ -3498,8 +3501,10 @@ search_free:
 					       obj->cache_level,
 					       start, end,
 					       flags);
-		if (ret == 0)
+		if (ret == 0) {
+			DRM_DEBUG_DRIVER("drm_mm_insert_* failed... retrying\n");
 			goto search_free;
+                }
 
 		goto err_free_vma;
 	}
@@ -3509,8 +3514,10 @@ search_free:
 	}
 
 	ret = i915_gem_gtt_prepare_object(obj);
-	if (ret)
+	if (ret) {
+		DRM_DEBUG_DRIVER("i915_gem_gtt_prepare_object failed\n");
 		goto err_remove_node;
+	}
 
 	/*  allocate before insert / bind */
 	if (vma->vm->allocate_va_range) {
@@ -3884,8 +3891,10 @@ i915_gem_object_pin_to_display_plane(struct drm_i915_gem_object *obj,
 
 	if (pipelined != i915_gem_request_get_ring(obj->last_read_req)) {
 		ret = i915_gem_object_sync(obj, pipelined);
-		if (ret)
+		if (ret) {
+			DRM_DEBUG_DRIVER("i915_gem_object_sync failed\n");
 			return ret;
+		}
 	}
 
 	/* Mark the pin_display early so that we account for the
@@ -3905,8 +3914,10 @@ i915_gem_object_pin_to_display_plane(struct drm_i915_gem_object *obj,
 	 */
 	ret = i915_gem_object_set_cache_level(obj,
 					      HAS_WT(obj->base.dev) ? I915_CACHE_WT : I915_CACHE_NONE);
-	if (ret)
-		goto err_unpin_display;
+	if (ret) {
+		DRM_DEBUG_DRIVER("i915_gem_object_set_cache_level failed\n");
+ 		goto err_unpin_display;
+	}
 
 	/* As the user may map the buffer once pinned in the display plane
 	 * (e.g. libkms for the bootup splash), we have to ensure that we
@@ -3915,8 +3926,10 @@ i915_gem_object_pin_to_display_plane(struct drm_i915_gem_object *obj,
 	ret = i915_gem_object_ggtt_pin(obj, view, alignment,
 				       view->type == I915_GGTT_VIEW_NORMAL ?
 				       PIN_MAPPABLE : 0);
-	if (ret)
-		goto err_unpin_display;
+	if (ret) {
+		DRM_DEBUG_DRIVER("i915_gem_obj_ggtt_pin failed\n");
+ 		goto err_unpin_display;
+	}
 
 	i915_gem_object_flush_cpu_write_domain(obj);
 
@@ -4158,8 +4171,10 @@ i915_gem_object_do_pin(struct drm_i915_gem_object *obj,
 		 */
 		vma = i915_gem_object_bind_to_vm(obj, vm, ggtt_view, alignment,
 						 flags);
-		if (IS_ERR(vma))
-			return PTR_ERR(vma);
+		if (IS_ERR(vma)) {
+			DRM_DEBUG_DRIVER("i915_gem_object_bind_to_vm failed\n");
+ 			return PTR_ERR(vma);
+		}
 	}
 
 	if (flags & PIN_GLOBAL && !(vma->bound & GLOBAL_BIND)) {
diff --git a/drivers/gpu/drm/i915/i915_gem_foreign.c b/drivers/gpu/drm/i915/i915_gem_foreign.c
index 80eaf71..884ecc0 100644
--- a/drivers/gpu/drm/i915/i915_gem_foreign.c
+++ b/drivers/gpu/drm/i915/i915_gem_foreign.c
@@ -72,6 +72,12 @@ i915_gem_foreign_remove_override(struct i915_gem_foreign_object *vmap,
 	for (i = 0; i < num_pages; i++)
 		if (m2p_remove_override(vmap->pvec[i], NULL, vmap->mfns[i]))
 			BUG();
+		if (!(i % 100)) {
+			DRM_DEBUG_DRIVER("Foreign unmap(%d) pfn = %lx, kaddr = %p\n",
+					 i, page_to_pfn(vmap->pvec[i]),
+					 pfn_to_kaddr(page_to_pfn(vmap->pvec[i])));
+
+		}
 }
 
 static int
@@ -82,6 +88,7 @@ i915_gem_foreign_get_pages(struct drm_i915_gem_object *obj)
 	struct scatterlist *sg = NULL;
 	int i, ret;
 
+        DRM_DEBUG_DRIVER("Foreign get pages.\n");
 	vmap->pvec = kmalloc(vmap->num_pages * sizeof(struct page *),
 			 GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
 	if (vmap->pvec == NULL) {
@@ -127,9 +134,18 @@ i915_gem_foreign_get_pages(struct drm_i915_gem_object *obj)
 			i915_gem_foreign_remove_override(vmap, i - 1);
 			goto err1;
 		}
+		if (!(i % 100)) {
+			DRM_DEBUG_DRIVER("Foreign map(%d) mfn = %llx, pfn = %lx, kaddr = %p, valid = %d\n",
+					 i, vmap->mfns[i], page_to_pfn(vmap->pvec[i]),
+					 pfn_to_kaddr(page_to_pfn(vmap->pvec[i])),
+					 virt_addr_valid(pfn_to_kaddr(page_to_pfn(vmap->pvec[i]))));
+		}
 	}
 
 	for_each_sg(st->sgl, sg, vmap->num_pages, i) {
+		if (!(i % 100)) {
+			DRM_DEBUG_DRIVER("Foreign page[%d] = %p\n", i, vmap->pvec[i]);
+		}
 		sg_set_page(sg, vmap->pvec[i], PAGE_SIZE, 0);
 	}
 
@@ -155,6 +171,7 @@ i915_gem_foreign_put_pages(struct drm_i915_gem_object *obj)
 	struct i915_gem_foreign_object *vmap = to_foreign_object(obj);
 	int num_pages = obj->base.size >> PAGE_SHIFT;
 
+        DRM_DEBUG_DRIVER("Foreign put pages.\n");
 	i915_gem_foreign_remove_override(vmap, num_pages);
 
 	i915_gem_foreign_free_pages(vmap, num_pages);
@@ -192,6 +209,8 @@ i915_gem_foreign_ioctl(struct drm_device *dev, void *data,
 	int ret = -ENOMEM;
 	u32 handle;
 
+	DRM_DEBUG_DRIVER("Foreign init - mfns:%p num_pages:0x%x flags: 0x%x\n",
+			 args->mfns, args->num_pages, args->flags);
 	if ((args->num_pages * PAGE_SIZE) > dev_priv->gtt.base.total)
 		return -E2BIG;
 
