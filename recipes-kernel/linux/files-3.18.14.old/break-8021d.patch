diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index 8f16498..3f3d964 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -343,6 +343,7 @@ static struct net_bridge_port *new_nbp(struct net_bridge *br,
 int br_add_bridge(struct net *net, const char *name)
 {
 	struct net_device *dev;
+        struct net_bridge *br;
 	int res;
 
 	dev = alloc_netdev(sizeof(struct net_bridge), name, NET_NAME_UNKNOWN,
@@ -350,6 +351,9 @@ int br_add_bridge(struct net *net, const char *name)
 
 	if (!dev)
 		return -ENOMEM;
+        
+        br = netdev_priv(dev);
+	br->break_8021d = 0;
 
 	dev_net_set(dev, net);
 	dev->rtnl_link_ops = &br_link_ops;
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index 6fd5522..1bb5093 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -197,8 +197,8 @@ rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
 		case 0x00:	/* Bridge Group Address */
 			/* If STP is turned off,
 			   then must forward to keep loop detection */
-			if (p->br->stp_enabled == BR_NO_STP ||
-			    fwd_mask & (1u << dest[5]))
+			if ((p->br->stp_enabled == BR_NO_STP ||
+			    fwd_mask & (1u << dest[5])) && p->br->break_8021d)
 				goto forward;
 			break;
 
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 6da61d2..cdf8aeb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -289,7 +289,7 @@ struct net_bridge
 	struct bridge_mcast_querier	ip6_querier;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
-
+        u8				break_8021d;
 	struct timer_list		hello_timer;
 	struct timer_list		tcn_timer;
 	struct timer_list		topology_change_timer;
diff --git a/net/bridge/br_sysfs_br.c b/net/bridge/br_sysfs_br.c
index c8470e0..3217064 100644
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@ -710,6 +710,37 @@ static ssize_t nf_call_arptables_store(
 }
 static DEVICE_ATTR_RW(nf_call_arptables);
 #endif
+
+static ssize_t show_break_8021d(struct device *d,
+				struct device_attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%x\n", to_bridge(d)->break_8021d);
+}
+
+static ssize_t store_break_8021d(struct device *d,
+				 struct device_attribute *attr,
+				 const char *buf, size_t len)
+{
+	struct net_bridge *br = to_bridge(d);
+
+	spin_lock_bh(&br->lock);
+	switch (buf[0]) {
+	case '1':
+		br->break_8021d = 1;
+		break;
+	case '0':
+		br->break_8021d = 0;
+		break;
+	}
+
+	spin_unlock_bh(&br->lock);
+	return len;
+}
+
+static DEVICE_ATTR(break_8021d, S_IRUGO | S_IWUSR, show_break_8021d, store_break_8021d);
+
+
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 static ssize_t vlan_filtering_show(struct device *d,
 				   struct device_attribute *attr,
@@ -807,6 +838,7 @@ static struct attribute *bridge_attrs[] = {
 	&dev_attr_vlan_protocol.attr,
 	&dev_attr_default_pvid.attr,
 #endif
+        &dev_attr_break_8021d.attr,
 	NULL
 };
 
